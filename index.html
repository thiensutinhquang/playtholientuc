<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>üìú Danh s√°ch c√°c b√†i th∆°</title>
  <!-- Link Google Fonts for Inter font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Global Reset/Box-sizing for consistent layout */
    *, *::before, *::after {
      box-sizing: border-box;
    }

    /* General body styles */
    body {
      font-family: 'Inter', sans-serif; /* Use Inter font as primary */
      background: #f8f9fa; /* Lighter background for a cleaner look */
      margin: 0;
      padding: 1rem; /* Use rem for better scalability */
      line-height: 1.6;
      color: #343a40; /* Darker text for better contrast */
      text-rendering: optimizeLegibility; /* Improve font rendering */
      -webkit-font-smoothing: antialiased; /* Smooth fonts on Webkit browsers */
      -moz-osx-font-smoothing: grayscale; /* Smooth fonts on Firefox */
      /* Adjusted padding-bottom for fixed player bar height + offset */
      padding-bottom: 170px; /* Base padding for desktop (70px offset + estimated bar height ~100px) */
    }

    /* Main container styling */
    .container {
      max-width: 960px; /* Slightly wider for more content */
      margin: 1.5rem auto; /* More vertical margin */
      background: #ffffff;
      border-radius: 12px; /* More rounded corners */
      padding: 1.5rem; /* More internal padding */
      box-shadow: 0 8px 25px rgba(0,0,0,0.1); /* Deeper shadow */
      overflow: hidden; /* Ensures no content spills out */
      transition: all 0.3s ease-in-out; /* Smooth transitions for any size changes */
    }

    /* Header Container for Title and Nav Buttons */
    .header-container {
        display: flex;
        justify-content: space-between; /* Pushes h1 and nav to opposite ends */
        align-items: center;
        flex-wrap: wrap; /* Allow wrapping on smaller screens */
        margin-bottom: 1rem;
    }

    /* Main heading styling */
    h1 {
      text-align: center; /* Initial alignment, might be overridden by flex */
      font-size: 2.2rem; /* Larger font size */
      color: #007bff;
      margin: 0; /* Remove default margin */
      font-weight: 700; /* Bolder font */
      letter-spacing: -0.5px; /* Slight letter spacing adjustment */
      flex-shrink: 1; /* Allow to shrink if needed */
      min-width: 200px; /* Ensure title doesn't disappear */
    }

    /* Header Navigation (buttons on the right) */
    .header-nav {
        display: flex;
        gap: 0.5rem; /* Space between buttons */
        align-items: center;
        flex-shrink: 0; /* Prevent nav from shrinking */
        margin-left: auto; /* Push to the right */
        flex-wrap: wrap; /* Allow buttons to wrap if space is tight */
        justify-content: flex-end; /* Align buttons to the right if wrapped */
    }

    .header-nav .nav-button,
    .dropdown-toggle {
        padding: 0.6rem 1rem;
        font-size: 0.9rem;
        border-radius: 20px;
        border: none;
        background: #6c757d; /* A neutral gray */
        color: #fff;
        cursor: pointer;
        transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
        text-decoration: none; /* For anchor tags styled as buttons */
        display: inline-flex; /* For centering text/icons */
        align-items: center;
        white-space: nowrap; /* Prevent text wrapping */
        box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .header-nav .nav-button:hover,
    .dropdown-toggle:hover {
        background: #5a6268; /* Darker gray on hover */
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }

    /* Dropdown container */
    .dropdown {
        position: relative;
        display: inline-block;
    }

    .dropdown-menu {
        display: none;
        position: absolute;
        background-color: #f9f9f9;
        min-width: 180px; /* Increased min-width for better spacing */
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1001; /* Higher z-index to be above other elements */
        right: 0; /* Align to right of parent button */
        border-radius: 8px;
        overflow: hidden;
        padding: 5px 0; /* Padding inside the menu */
    }

    .dropdown-menu a {
        color: #343a40;
        padding: 10px 15px; /* Adjusted padding */
        text-decoration: none;
        display: flex; /* Use flex for icon and text alignment */
        align-items: center;
        gap: 8px; /* Space between icon and text */
        white-space: nowrap; /* Prevent wrapping */
        transition: background-color 0.2s ease;
        font-size: 0.95rem;
    }

    .dropdown-menu a:hover {
        background-color: #e9ecef;
    }

    .dropdown.active .dropdown-menu {
        display: block;
    }

    /* Search wrapper for positioning input and suggestions */
    #search-wrapper {
        position: relative; /* Establish positioning context for suggestions */
        margin-top: 0.5rem; /* Space between h1 and search input */
        margin-bottom: 0.5rem; /* Adjusted for result count */
    }

    /* Search input field */
    #search {
      width: 100%;
      padding: 0.8rem 1rem; /* Adjusted padding */
      font-size: 1rem;
      border-radius: 8px;
      border: 1px solid #ced4da; /* Lighter border color */
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.08); /* Subtle inner shadow */
      transition: border-color 0.3s ease, box-shadow 0.3s ease, border-radius 0.2s ease;
    }
    #search::placeholder {
      color: #6c757d; /* Placeholder color */
    }
    #search:focus {
      border-color: #007bff;
      box-shadow: 0 0 0 0.2rem rgba(0,123,255,0.25); /* Focus ring effect */
      outline: none;
    }

    /* Search suggestions container */
    #search-suggestions {
        position: absolute;
        top: 100%; /* Position directly below the input in its wrapper */
        left: 0;
        right: 0;
        background-color: #fff;
        border: 1px solid #ddd;
        border-radius: 0 0 8px 8px; /* Rounded corners only at the bottom */
        box-shadow: 0 4px 15px rgba(0,0,0,0.15);
        z-index: 10; /* Ensure it's above other content */
        max-height: 120px; /* Reduced max-height for compactness */
        overflow-y: auto;
        display: none; /* Hidden by default */
        list-style: none; /* Remove list bullets */
        padding: 0;
        margin: 0;
    }
    /* Individual suggestion item */
    #search-suggestions li {
        padding: 0.5rem 0.8rem; /* Reduced padding for compactness */
        font-size: 0.9rem; /* Reduced font size for compactness */
        color: #343a40;
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    #search-suggestions li:hover {
        background-color: #f1f1f1;
    }
    #search-suggestions li:not(:last-child) {
        border-bottom: 1px solid #eee; /* Separator between items */
    }

    /* Styles when suggestions are open to make input and suggestions visually connect */
    #search-wrapper.suggestions-open #search {
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
      border-bottom-color: transparent; /* Make border invisible */
    }
    #search-wrapper.suggestions-open #search-suggestions {
      border-top-left-radius: 0;
      border-top-right-radius: 0;
      border-top: none; /* Remove top border */
    }

    /* Additional styles for search-results-info */
    #search-results-info {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #555;
      text-align: center;
      padding: 0.3rem 0;
      display: none; /* Hidden by default */
    }

    /* For displaying search results count */
    #search-result-count {
      margin: 0 0 1rem; /* Adjust margin as per instruction */
      color: #555;
      font-weight: 500;
      text-align: center;
    }


    /* Table of Contents (TOC) layout */
    .toc {
      display: flex;
      overflow-x: auto; /* Enable horizontal scrolling */
      gap: 0.75rem; /* Consistent gap */
      padding-bottom: 0.5rem; /* Padding for scrollbar visibility */
      -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
      /* Custom scrollbar styles for Firefox */
      scrollbar-width: thin;
      scrollbar-color: #007bff #e9ecef;
    }
    /* Custom scrollbar styles for Webkit (Chrome, Safari) */
    .toc::-webkit-scrollbar {
      height: 7px; /* Thinner scrollbar */
    }
    .toc::-webkit-scrollbar-track {
      background: #e9ecef;
      border-radius: 10px;
    }
    .toc::-webkit-scrollbar-thumb {
      background: #007bff;
      border-radius: 10px;
      transition: background 0.3s ease;
    }
    .toc::-webkit-scrollbar-thumb:hover {
      background: #0056b3;
    }

    .toc a {
      flex-shrink: 0; /* Prevents items from shrinking */
      background: #e9ecef;
      padding: 0.5rem 1rem; /* Adjusted padding */
      border-radius: 25px; /* Fully rounded pills */
      text-decoration: none;
      color: #495057;
      font-size: 0.95rem;
      white-space: nowrap; /* Keep text on single line */
      transition: background 0.3s ease, color 0.3s ease, box-shadow 0.3s ease, transform 0.2s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,0.06); /* Subtle shadow */
    }
    .toc a:hover {
      background: #d0e7ff; /* Lighter blue on hover */
      color: #0056b3;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
      transform: translateY(-1px); /* Slight lift on hover */
    }
    .toc a.active {
      background: #007bff;
      color: #fff;
      font-weight: 600; /* Bolder for active state */
      box-shadow: 0 5px 15px rgba(0,123,255,0.35); /* More prominent shadow for active */
      transform: translateY(-2px); /* More lift for active state */
    }

    /* Details (Accordion Item) styling */
    details {
      margin: 1rem 0; /* Consistent margin */
      border: 1px solid #e0e0e0;
      border-radius: 10px; /* Slightly more rounded */
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08); /* Improved shadow */
      transition: box-shadow 0.3s ease, transform 0.2s ease;
    }
    details:hover {
        transform: translateY(-2px); /* Slight lift on hover */
        box-shadow: 0 6px 16px rgba(0,0,0,0.12);
    }
    details[open] {
      box-shadow: 0 8px 20px rgba(0,0,0,0.15); /* More prominent shadow when open */
      transform: translateY(-2px); /* Keep lifted when open */
    }

    summary {
      cursor: pointer;
      padding: 1rem 1.25rem 1rem 2.5rem; /* Increased left padding for icon space */
      background: #f1f3f5; /* Lighter background for summary */
      font-weight: 600; /* Bolder text */
      color: #212529;
      list-style: none; /* Remove default marker */
      position: relative;
      transition: background 0.3s ease;
      font-size: 1.1rem; /* Slightly larger summary text */
    }
    summary:hover {
      background: #e9ecef; /* Subtle hover effect */
    }
    summary::-webkit-details-marker {
      display: none; /* Hide Webkit marker */
    }
    summary::before {
      content: '‚ñ∫'; /* Custom arrow icon */
      position: absolute;
      left: 1rem; /* Keep icon at 1rem from left edge */
      top: 50%;
      transform: translateY(-50%) rotate(0deg);
      transition: transform 0.2s ease;
      font-size: 0.75rem; /* Smaller arrow */
      color: #007bff;
    }
    details[open] summary::before {
      transform: translateY(-50%) rotate(90deg); /* Rotate arrow when open */
    }

    /* Highlighting for search results */
    mark.highlight { /* Changed from .highlight to mark.highlight for more specific styling */
      background-color: #ffee00; /* Bright yellow highlight */
      font-weight: bold;
      padding: 0 2px; /* Small padding for visual separation */
      border-radius: 3px;
    }

    .content-body {
      padding: 1.25rem; /* Consistent padding */
      background: #ffffff;
      border-top: 1px solid #e9ecef; /* Lighter border */
      font-size: 1rem;
      color: #495057;
    }

    img {
      max-width: 100%;
      height: auto;
      border-radius: 8px;
      margin-top: 1rem;
      display: block;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    /* Fixed Player Bar */
    .fixed-player-bar {
        position: fixed;
        bottom: 70px; /* Raised by 70px as requested */
        left: 0;
        width: 100%;
        background-color: #ffffff;
        box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
        padding: 10px 1rem; /* Base padding (top, right, bottom, left) */
        padding-right: 100px; /* Added extra padding on the right for the Top button */
        z-index: 1000; /* Ensure it stays on top */
        display: flex;
        flex-direction: column; /* Stack rows vertically */
        align-items: center; /* Center rows horizontally */
        gap: 8px; /* Space between the two rows */
    }

    /* Player Row 1 - Main Controls */
    .player-row-1 {
        display: flex;
        flex-wrap: nowrap;
        gap: 0.75rem; /* Default gap */
        align-items: center;
        width: 100%; /* Takes full width of parent, considering parent's padding */
        justify-content: center; /* Center controls within the row */
        overflow-x: auto;
        padding-bottom: 5px; /* Space for scrollbar on some browsers */

        /* Custom scrollbar for controls if overflow-x is active */
        scrollbar-width: thin;
        scrollbar-color: #007bff #e9ecef;
    }
    .player-row-1::-webkit-scrollbar {
        height: 5px;
    }
    .player-row-1::-webkit-scrollbar-track {
        background: #e9ecef;
        border-radius: 10px;
    }
    .player-row-1::-webkit-scrollbar-thumb {
        background: #007bff;
        border-radius: 10px;
    }

    /* Player Row 2 - Prev/Next and Progress */
    .player-row-2 {
        display: flex;
        flex-wrap: nowrap;
        gap: 0.75rem; /* Default gap */
        align-items: center;
        width: 100%; /* Takes full width of parent, considering parent's padding */
        justify-content: center; /* Center controls within the row */
    }


    /* General button styling for player controls */
    .speech-controls button,
    .player-row-2 button {
      flex-shrink: 0; /* Prevent buttons from shrinking too much */
      min-width: 90px; /* A reasonable minimum width for buttons */
      padding: 0.6rem 1.2rem; /* Adjusted padding for better touch target */
      font-size: 0.95rem;
      border-radius: 25px; /* Fully rounded buttons */
      border: none;
      background: #007bff;
      color: #fff;
      cursor: pointer;
      transition: background 0.1s ease, transform 0.1s ease, box-shadow 0.1s ease; /* Faster transitions for active feedback */
      box-shadow: 0 4px 12px rgba(0,123,255,0.25);
    }
    .speech-controls button:hover,
    .player-row-2 button:hover {
      background: #0056b3;
      transform: translateY(-3px); /* More pronounced lift */
      box-shadow: 0 6px 15px rgba(0,123,255,0.35);
    }
    /* Enhanced :active state for general buttons */
    .speech-controls button:active,
    .player-row-2 button:active {
      transform: translateY(0.5px) scale(0.98); /* Slight press effect */
      background: #004080; /* Darker blue on press */
      box-shadow: 0 1px 3px rgba(0,123,255,0.3); /* Softer shadow on press */
    }

    /* Specific style for auto-play (loop) button when active */
    .speech-controls button.active-auto {
      background: #4CAF50; /* A brighter, more distinct green */
      box-shadow: 0 6px 15px rgba(76, 175, 80, 0.4); /* More pronounced shadow */
      border: 2px solid #388E3C; /* A darker green border for emphasis */
      color: #fff; /* Ensure text remains white for contrast */
      font-weight: bold; /* Make text bolder */
    }
    .speech-controls button.active-auto:hover {
      background: #388E3C; /* Darker green on hover */
      box-shadow: 0 8px 20px rgba(76, 175, 80, 0.5); /* Even more pronounced shadow on hover */
    }
    /* Enhanced :active state for active-auto (Loop) button */
    .speech-controls button.active-auto:active {
        background: #1B5E20; /* Even darker green on press for active loop */
        transform: translateY(1.5px) scale(0.96); /* More pronounced press effect */
        box-shadow: 0 2px 5px rgba(76, 175, 80, 0.4); /* Softer shadow on press */
        border: 2px solid #1B5E20; /* Keep border consistent on press */
    }

    /* New style for the loop button when it is NOT active (i.e., default for loop button) */
    .speech-controls button.loop-toggle-button:not(.active-auto) {
        background: #6c757d; /* A neutral gray, distinct from blue and green */
        color: #fff;
        border: 2px solid transparent; /* Transparent border for consistency */
    }
    .speech-controls button.loop-toggle-button:not(.active-auto):hover {
        background: #5a6268; /* Darker gray on hover */
    }
    .speech-controls button.loop-toggle-button:not(.active-auto):active {
        background: #495057; /* Even darker gray on press */
        transform: translateY(0.5px) scale(0.98);
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }


    /* Styles for volume/rate labels and their sliders */
    .speech-controls label {
      display: flex;
      align-items: center;
      gap: 0.2em; /* Small gap between emoji and slider */
      flex-shrink: 0; /* Prevent label group from shrinking */
      font-size: 1.3em; /* Make emoji slightly larger for visibility */
      color: #343a40; /* Consistent color for icons */
      /* No explicit width, let content define it */
    }

    /* Sliders within labels */
    .speech-controls label input[type=range] {
        -webkit-appearance: none;
        appearance: none;
        height: 8px; /* Thicker track */
        background: #e9ecef; /* Lighter track background */
        border-radius: 4px;
        outline: none;
        transition: opacity 0.2s;
        flex-grow: 1; /* Allow slider to take available space within its label */
        flex-shrink: 1; /* Allow slider to shrink */
        width: 70px; /* Initial width, will be affected by flex-grow/shrink */
        min-width: 50px; /* Slightly increased min-width for usability */
    }
    .speech-controls input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px; /* Larger thumb */
      height: 20px; /* Larger thumb */
      border-radius: 50%;
      background: #007bff;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      margin-top: -6px; /* Adjust thumb position */
      transition: background 0.3s ease, box-shadow 0.3s ease;
    }
    .speech-controls input[type=range]::-webkit-slider-thumb:hover {
        background: #0056b3;
        box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
    .speech-controls input[type=range]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #007bff;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      transition: background 0.3s ease, box-shadow 0.3s ease;
    }
    .speech-controls input[type=range]::-moz-range-thumb:hover {
        background: #0056b3;
        box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }

    /* Progress bar */
    .speech-progress {
        flex-grow: 1; /* Progress bar takes remaining space */
        flex-shrink: 1; /* Allow it to shrink */
        min-width: 120px; /* Increased min-width for better visibility */
        height: 8px;
        background: #e9ecef;
        border-radius: 4px;
        overflow: hidden;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
    }
    .speech-progress-bar {
      height: 100%;
      background: linear-gradient(to right, #007bff, #20c997); /* More vibrant gradient */
      width: 0%;
      transition: width 0.2s ease-out;
      border-radius: 4px;
    }

    /* Scroll to Top Button */
    .scroll-to-top-button {
        position: absolute; /* Position relative to .fixed-player-bar */
        top: 10px; /* Position at the top of the fixed bar */
        right: 1rem; /* Position at the right of the fixed bar */
        z-index: 1002; /* Ensure it's above other elements */

        /* Keep original styling for appearance */
        flex-shrink: 0;
        padding: 0.5rem 0.8rem;
        font-size: 0.85rem;
        line-height: 1.2; /* For multiline text/emoji */
        border-radius: 15px;
        border: none;
        background: #17a2b8; /* A distinct color, e.g., info blue */
        color: #fff;
        cursor: pointer;
        transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
        text-align: center;
        box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
    .scroll-to-top-button:hover {
        background: #138496;
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }


    /* Fallback message styling */
    #fallback {
      display: none;
      text-align: center;
      margin-top: 2rem;
      padding: 1.5rem;
      background: #fff3cd; /* Warning yellow background */
      border: 1px solid #ffeeba;
      border-radius: 8px;
      color: #856404;
      font-size: 1rem;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    #fallback a {
      color: #007bff;
      text-decoration: underline;
      font-weight: bold;
    }
    #fallback a:hover {
      color: #0056b3;
    }

    /* Responsive adjustments for smaller screens */
    @media (max-width: 768px) {
      body {
        padding: 0.75rem;
        /* Adjusted padding for mobile fixed bar (70px offset + estimated bar height) */
        padding-bottom: 140px; 
      }
      .container {
        margin: 1rem auto;
        padding: 1rem;
        border-radius: 8px;
      }
      .header-container {
        flex-direction: column; /* Stack title and nav vertically */
        align-items: center; /* Center items when stacked */
        gap: 0.8rem; /* Space between stacked items */
      }
      h1 {
        font-size: 1.8rem;
        margin-bottom: 0.5rem; /* Reduced margin when stacked */
        text-align: center; /* Ensure title is centered when stacked */
      }
      .header-nav {
        width: 100%; /* Take full width when stacked */
        justify-content: center; /* Center buttons horizontally */
        margin-left: 0; /* Remove auto margin */
      }
      .header-nav .nav-button,
      .dropdown-toggle {
          padding: 0.5rem 0.8rem;
          font-size: 0.85rem;
          border-radius: 15px;
      }
      .dropdown-menu {
          min-width: 150px; /* Adjusted min-width for mobile dropdown */
      }
      .dropdown-menu a {
          padding: 8px 12px;
          font-size: 0.9rem;
      }
      #search-wrapper {
        margin-top: 0.5rem;
        margin-bottom: 1rem; /* Adjust for smaller screens */
      }
      #search {
        padding: 0.7rem 0.8rem;
        font-size: 0.95rem;
      }
      .toc {
        margin-top: 1rem; /* Adjust for smaller screens */
        padding-bottom: 0.4rem;
      }
      .toc a {
        padding: 0.4rem 0.8rem;
        font-size: 0.85rem;
        border-radius: 20px;
      }
      details {
        margin: 0.8rem 0;
        border-radius: 8px;
      }
      summary {
        padding: 0.8rem 1rem 0.8rem 2rem; /* Adjusted left padding for mobile */
        font-size: 1rem;
      }
      summary::before {
        left: 0.8rem; /* Adjusted icon position for mobile */
      }
      .content-body {
        padding: 1rem;
        font-size: 0.95rem;
      }
      /* Fixed Player Bar adjustments for mobile */
      .fixed-player-bar {
        padding: 8px 0.75rem; /* Smaller padding for mobile */
        padding-right: 80px; /* Adjusted padding for mobile Top button */
        bottom: 70px; /* Remains 70px from the bottom */
      }
      /* Speech controls adjustments for mobile */
      .player-row-1 {
        gap: 0.3rem; /* Slightly smaller gap for better compactness */
        justify-content: flex-start; /* Maintain align to start */
      }
      .player-row-2 {
          gap: 0.4rem; /* Smaller gap for mobile */
      }
      .speech-controls button,
      .player-row-2 button {
          min-width: 55px; /* Slightly reduced min-width for better compactness */
          padding: 0.5rem 0.6rem; /* Adjusted padding for compactness */
          font-size: 0.8em; /* Slightly smaller font for compactness */
      }
      .speech-controls label {
          font-size: 1em; /* Reduced for compactness */
          gap: 0.1em; /* Even smaller gap */
      }
      .speech-controls label input[type=range] {
          width: 50px; /* Reduced width */
          min-width: 35px; /* Reduced min-width */
      }
      .speech-progress {
          min-width: 80px; /* Reduced min-width */
      }
      .scroll-to-top-button {
        padding: 0.4rem 0.6rem;
        font-size: 0.75rem;
        right: 0.75rem; /* Adjusted for mobile padding */
        top: 8px; /* Adjusted to new player bar top padding */
      }
    }

    @media (max-width: 480px) {
      body {
        padding: 0.5rem;
        /* Further adjusted padding for smallest mobile fixed bar */
        padding-bottom: 120px; /* Estimated: 70px offset + ~50px bar height */
      }
      .container {
        padding: 0.8rem;
      }
      h1 {
        font-size: 1.5rem;
      }
      .toc a {
        font-size: 0.8rem;
        padding: 0.3rem 0.6rem;
      }
      summary {
        font-size: 0.9rem;
        padding: 0.7rem 0.8rem 0.7rem 1.8rem; /* Further adjusted left padding for smallest mobile */
      }
      summary::before {
        left: 0.7rem; /* Further adjusted icon position for smallest mobile */
      }
      .content-body {
        padding: 0.8rem;
      }
      .speech-controls {
          gap: 0.2rem; /* Even smaller gap for very small screens */
      }
      .player-row-2 {
          gap: 0.3rem;
      }
      .speech-controls button,
      .player-row-2 button {
          min-width: 45px; /* Even smaller min-width */
          padding: 0.3rem 0.5rem; /* Even smaller padding */
          font-size: 0.8em;
      }
      .speech-controls label {
          font-size: 0.9em;
          gap: 0.1em;
      }
      .speech-controls label input[type=range] {
          width: 40px; /* Even smaller width */
          min-width: 25px; /* Even smaller min-width */
      }
      .speech-progress {
          min-width: 60px; /* Even smaller min-width */
      }
      .scroll-to-top-button {
        padding: 0.3rem 0.5rem;
        font-size: 0.7rem;
        right: 0.5rem; /* Adjusted for smallest mobile padding */
        top: 8px; /* Consistent with 768px breakpoint */
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header-container">
      <h1>üìú Danh s√°ch c√°c b√†i th∆°</h1>
      <div class="header-nav">
        <a href="https://sites.google.com/view/thiensutinhquang" target="_blank" class="nav-button">Trang ch·ªß</a>
        <a href="https://sites.google.com/view/thiensutinhquang/%C3%A2m-nh%E1%BA%A1c" target="_blank" class="nav-button">Nghe nh·∫°c</a>
        <div class="dropdown">
          <button class="dropdown-toggle">N·ªÅn t·∫£ng ‚ñæ</button>
          <div class="dropdown-menu">
            <a href="https://www.youtube.com/channel/UCLdLj1-g4TI5lSmWeD60mnA" target="_blank">üì∫ Youtube</a>
            <a href="https://www.tiktok.com/@minhsutinhquang" target="_blank">üéµ TikTok</a>
            <a href="https://www.facebook.com/phatphapnhiemmauTinhQuang" target="_blank">üìò Facebook</a>
            <a href="https://t.me/Giaoly_phap_don_ngo" target="_blank">üí¨ Zalo</a>
          </div>
        </div>
      </div>
    </div>
    
    <div id="search-wrapper"> <!-- New wrapper for search input and suggestions -->
        <input type="text" id="search" placeholder="T√¨m ki·∫øm b√†i th∆°..." autocomplete="off"/>
        <ul id="search-suggestions"></ul> <!-- Changed to ul for semantic list -->
        <div id="search-results-info"></div> <!-- For displaying search results count - this is replaced by search-result-count -->
    </div>
    <p id="search-result-count" style="margin: 0 0 1rem; color: #555; font-weight: 500; text-align: center;"></p> <!-- Added search result count -->
    <div class="toc" id="toc">ƒêang t·∫£i d·ªØ li·ªáu...</div>
    <div id="accordion"></div>
    <div id="fallback" style="display:none; text-align:center; margin-top:20px;">
      ‚ö†Ô∏è Tr√¨nh duy·ªát hi·ªán t·∫°i kh√¥ng h·ªó tr·ª£ hi·ªÉn th·ªã d·ªØ li·ªáu t·ª´ Google Sheets.<br>
      <a href="https://docs.google.com/spreadsheets/d/e/2PACX-1vTjl66tsHr053yFDCTxSKViC0G24MNzmaW7ofFMMSMJVwHBOslw6usujYUvcDnnymA7ZFbL1BZ6QEYf/pubhtml" target="_blank">Xem danh s√°ch b√†i th∆° t·∫°i ƒë√¢y</a>.
    </div>
  </div>

  <!-- This is the new fixed player bar -->
  <div class="fixed-player-bar">
    <div class="player-row-1">
        <!-- These elements will be moved here from inside the details section dynamically -->
        <!-- They are initially empty and will be populated by JS when a poem is opened -->
    </div>
    <div class="player-row-2">
        <!-- New previous/next buttons and progress bar -->
    </div>
    <button id="scroll-to-top-button" class="scroll-to-top-button">
      ‚¨ÜÔ∏è<br>Top
    </button>
  </div>


  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <!-- Fuse.js for fuzzy searching -->
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>

  <script>
    // URL c·ªßa Google Sheet ƒë√£ publish d∆∞·ªõi d·∫°ng CSV
    const SHEET_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTjl66tsHr053yFDCTxSKViC0G24MNzmaW7ofFMMSMJVwHBOslw6usujYUvcDnnymA7ZFbL1BZ6QEYf/pub?output=csv";
    let originalData = []; // L∆∞u tr·ªØ d·ªØ li·ªáu g·ªëc t·ª´ Google Sheet
    let fuse = null; // Fuse.js instance
    let currentUtterance = null; // ƒê·ªëi t∆∞·ª£ng SpeechSynthesisUtterance hi·ªán t·∫°i
    let isPlaying = false; // Tr·∫°ng th√°i ph√°t √¢m thanh (ƒëang ph√°t hay d·ª´ng)
    let currentVolume = 1; // √Çm l∆∞·ª£ng hi·ªán t·∫°i (0-1)
    let currentRate = 1; // T·ªëc ƒë·ªô ƒë·ªçc hi·ªán t·∫°i (0.1-10)
    let progressInterval = null; // Bi·∫øn l∆∞u tr·ªØ ID c·ªßa setInterval cho thanh ti·∫øn tr√¨nh
    let currentIndex = -1; // Ch·ªâ s·ªë c·ªßa b√†i th∆° ƒëang ƒë∆∞·ª£c ph√°t
    let autoPlay = false; // Ch·∫ø ƒë·ªô t·ª± ƒë·ªông ph√°t li√™n t·ª•c

    // Bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u tr·ªØ ng·ªØ c·∫£nh c·ªßa b√†i th∆° ƒëang ph√°t
    let currentPlayingText = "";
    let currentPlayingProgressBar = null;
    let currentPlayingToggleButton = null;

    // Tham chi·∫øu ƒë·∫øn c√°c ph·∫ßn t·ª≠ DOM cho g·ª£i √Ω t√¨m ki·∫øm
    const searchInput = document.getElementById("search");
    const searchSuggestions = document.getElementById("search-suggestions");
    const searchWrapper = document.getElementById("search-wrapper"); // New reference to the wrapper
    const searchResultCountElement = document.getElementById("search-result-count"); // New reference for result count display
    const playerRow1Container = document.querySelector(".fixed-player-bar .player-row-1"); // Reference to the first row of controls
    const playerRow2Container = document.querySelector(".fixed-player-bar .player-row-2"); // Reference to the second row of controls
    const scrollToTopButton = document.getElementById("scroll-to-top-button"); // Reference to the new scroll-to-top button

    // Dropdown functionality
    const dropdownToggle = document.querySelector('.dropdown-toggle');
    const dropdownMenu = document.querySelector('.dropdown-menu');

    dropdownToggle.addEventListener('click', function() {
        this.closest('.dropdown').classList.toggle('active');
    });

    // Close the dropdown if the user clicks outside of it
    window.addEventListener('click', function(event) {
        if (!event.target.matches('.dropdown-toggle') && !event.target.closest('.dropdown-menu')) {
            const dropdowns = document.querySelectorAll('.dropdown');
            dropdowns.forEach(function(dropdown) {
                dropdown.classList.remove('active');
            });
        }
    });

    // Scroll to Top button functionality
    scrollToTopButton.addEventListener('click', () => {
        // This will scroll the window where the script is running (which is the iframe's window)
        window.scrollTo({ top: 0, behavior: 'smooth' });
    });


    /**
     * H√†m tr·ª£ gi√∫p ƒë·ªÉ lo·∫°i b·ªè d·∫•u ti·∫øng Vi·ªát v√† chuy·ªÉn v·ªÅ ch·ªØ th∆∞·ªùng.
     * @param {string} str - Chu·ªói ti·∫øng Vi·ªát c·∫ßn x·ª≠ l√Ω.
     * @returns {string} Chu·ªói ƒë√£ ƒë∆∞·ª£c lo·∫°i b·ªè d·∫•u v√† chuy·ªÉn v·ªÅ ch·ªØ th∆∞·ªùng.
     */
    function removeVietnameseAccents(str) {
      if (!str) return ''; // Handle null or undefined input
      str = str.replace(/√†|√°|·∫°|·∫£|√£|√¢|·∫ß|·∫•|·∫≠|·∫©|·∫´|ƒÉ|·∫±|·∫Ø|·∫∑|·∫≥|·∫µ/g, "a");
      str = str.replace(/√®|√©|·∫π|·∫ª|·∫Ω|√™|·ªÅ|·∫ø|·ªá|·ªÉ|·ªÖ/g, "e");
      str = str.replace(/√¨|√≠|·ªã|·ªâ|ƒ©/g, "i");
      str = str.replace(/√≤|√≥|·ªç|·ªè|√µ|√¥|·ªì|·ªë|·ªô|·ªï|·ªó|∆°|·ªù|·ªõ|·ª£|·ªü|·ª°/g, "o");
      str = str.replace(/√π|√∫|·ª•|·ªß|≈©|∆∞|·ª´|·ª©|·ª±|·ª≠|·ªØ/g, "u");
      str = str.replace(/·ª≥|√Ω|·ªµ|·ª∑|·ªπ/g, "y");
      str = str.replace(/ƒë/g, "d");
      str = str.replace(/√Ä|√Å|·∫†|·∫¢|√É|√Ç|·∫¶|·∫§|·∫¨|·∫®|·∫™|ƒÇ|·∫∞|·∫Æ|·∫∂|·∫≤|·∫¥/g, "A");
      str = str.replace(/√à|√â|·∫∏|·∫∫|·∫º|√ä|·ªÄ|·∫æ|·ªÜ|·ªÇ|·ªÑ/g, "E");
      str = str.replace(/√å|√ç|·ªä|·ªà|ƒ®/g, "I");
      str = str.replace(/√í|√ì|·ªå|·ªé|√ï|√î|·ªí|·ªê|·ªò|·ªî|·ªñ|∆†|·ªú|·ªö|·ª¢|·ªû|·ª†/g, "O");
      str = str.replace(/√ô|√ö|·ª§|·ª¶|≈®|∆Ø|·ª™|·ª®|·ª∞|·ª¨|·ªÆ/g, "U");
      str = str.replace(/·ª≤|√ù|·ª¥|·ª∂|·ª∏/g, "Y");
      str = str.replace(/ƒê/g, "D");
      return str.toLowerCase();
    }

    /**
     * T·∫°o index cho Fuse.js.
     * @param {Array} data - D·ªØ li·ªáu g·ªëc ƒë·ªÉ t·∫°o index.
     */
    function createFuseIndex(data) {
      fuse = new Fuse(data, {
        keys: [
          { name: "Ti√™u ƒë·ªÅ", weight: 0.7 },
          { name: "N·ªôi dung", weight: 0.3 }
        ],
        threshold: 0.4,           // Cho ph√©p sai ch√≠nh t·∫£ nh·∫π
        distance: 100,
        includeScore: true,
        minMatchCharLength: 2,
        ignoreLocation: true,
        shouldSort: true,
        includeMatches: true // Required for highlight
      });
    }

    /**
     * T·∫£i d·ªØ li·ªáu t·ª´ Google Sheet v√† hi·ªÉn th·ªã l√™n giao di·ªán.
     */
    async function loadData() {
      try {
        const response = await fetch(SHEET_URL);
        const csv = await response.text();
        // Ph√¢n t√≠ch c√∫ ph√°p CSV th√†nh d·ªØ li·ªáu JSON
        const { data } = Papa.parse(csv, { header: true, skipEmptyLines: true });
        originalData = data.filter(row => row["Ti√™u ƒë·ªÅ"] || row["N·ªôi dung"]); // Filter out empty rows

        // Initialize Fuse.js after data is loaded
        createFuseIndex(originalData);

        renderContent(originalData); // Render all original content initially
      } catch (e) {
        // X·ª≠ l√Ω l·ªói n·∫øu kh√¥ng t·∫£i ƒë∆∞·ª£c d·ªØ li·ªáu (v√≠ d·ª•: m·∫•t m·∫°ng, URL sai)
        console.error("L·ªói khi t·∫£i d·ªØ li·ªáu:", e);
        document.getElementById("toc").style.display = "none";
        document.getElementById("accordion").style.display = "none";
        document.getElementById("fallback").style.display = "block"; // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói
        searchInput.disabled = true; // Disable search input on error
        searchInput.placeholder = "T√¨m ki·∫øm kh√¥ng kh·∫£ d·ª•ng";
      }
    }

    /**
     * H√†m tr·ª£ gi√∫p ƒë·ªÉ highlight c√°c t·ª´ kh√≥a trong vƒÉn b·∫£n.
     * @param {string} text - VƒÉn b·∫£n g·ªëc.
     * @param {string} keyword - T·ª´ kh√≥a c·∫ßn highlight.
     * @returns {string} VƒÉn b·∫£n ƒë√£ ƒë∆∞·ª£c highlight d∆∞·ªõi d·∫°ng HTML.
     */
    function highlightKeyword(text, keyword) {
      if (!text) return text; // Handle null or undefined text input
      if (!keyword) return text;
      const normalizedKeyword = removeVietnameseAccents(keyword).trim();
      if (!normalizedKeyword) return text;

      // Escape special characters in the keyword for regex
      const escapedKeyword = normalizedKeyword.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
      const pattern = new RegExp(`(${escapedKeyword})`, 'gi'); // Use global and case-insensitive
      
      // Perform replace on the non-accented version for matching,
      // but use the original text for highlighting
      let result = "";
      let lastIndex = 0; // Initialize lastIndex
      const normalizedText = removeVietnameseAccents(text);
      let match;
      
      // Use exec in a loop for more robust matching
      while ((match = pattern.exec(normalizedText)) !== null) {
          const start = match.index;
          const end = start + match[0].length;
          result += text.substring(lastIndex, start);
          result += '<mark class="highlight">' + text.substring(start, end) + '</mark>'; // Use <mark>
          lastIndex = end;
      }
      result += text.substring(lastIndex);
      return result;
    }

    /**
     * Hi·ªÉn th·ªã n·ªôi dung c√°c b√†i th∆° (ho·∫∑c k·∫øt qu·∫£ t√¨m ki·∫øm) l√™n giao di·ªán.
     * @param {Array} displayData - M·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng b√†i th∆° ƒë·ªÉ hi·ªÉn th·ªã.
     */
    function renderContent(displayData) {
      const toc = document.getElementById("toc"); // Element cho m·ª•c l·ª•c
      const container = document.getElementById("accordion"); // Element cho ph·∫ßn n·ªôi dung (accordion)
      toc.innerHTML = ''; // X√≥a n·ªôi dung c≈©
      container.innerHTML = ''; // X√≥a n·ªôi dung c≈©

      const keyword = searchInput.value.trim();

      if (displayData.length === 0 && keyword !== "") {
          container.innerHTML = '<p style="text-align: center; margin-top: 20px; color: #6c757d;">Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ n√†o ph√π h·ª£p.</p>';
          searchResultCountElement.textContent = "Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ n√†o."; // Clear result message
          return;
      }

      displayData.forEach((row, i) => { // 'row' is now directly the poem object
        const originalIndex = originalData.indexOf(row); // Get the stable original index

        const title = row["Ti√™u ƒë·ªÅ"] || `B√†i ${originalIndex + 1}`;
        const content = row["N·ªôi dung"] || "";
        const image = row["·∫¢nh"] || "";

        // Apply highlighting
        const displayTitle = highlightKeyword(title, keyword);
        const displayContent = highlightKeyword(content.replace(/\n/g, "<br>"), keyword);

        // T·∫°o th·∫ª <details> cho m·ªói b√†i th∆°
        const details = document.createElement("details");
        details.id = `item-${originalIndex}`; // Use original index for stable ID

        // T·∫°o th·∫ª <summary> (ti√™u ƒë·ªÅ c√≥ th·ªÉ click ƒë·ªÉ m·ªü/ƒë√≥ng)
        const summary = document.createElement("summary");
        summary.innerHTML = displayTitle; // Use innerHTML for highlighted text
        summary.onclick = (e) => {
          e.preventDefault(); // NgƒÉn ch·∫∑n h√†nh vi m·∫∑c ƒë·ªãnh c·ªßa th·∫ª <details>/<summary> ƒë·ªÉ qu·∫£n l√Ω th·ªß c√¥ng

          const wasOpen = details.hasAttribute('open');
          const currentDetailIndex = originalIndex;

          // D·ª´ng b·∫•t k·ª≥ √¢m thanh n√†o ƒëang ph√°t
          speechSynthesis.cancel();
          isPlaying = false;
          // ƒê·∫∑t l·∫°i t·∫•t c·∫£ c√°c n√∫t play/pause v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
          document.querySelectorAll('.player-row-1 button').forEach(btn => {
            if (btn.innerHTML.includes("‚è∏Ô∏è")) {
                btn.innerHTML = "‚ñ∂Ô∏è Ph√°t";
            } else if (btn.innerHTML.includes("‚èØÔ∏è")) {
                btn.innerHTML = "‚èØÔ∏è Ph√°t/D·ª´ng";
            }
          });

          if (!wasOpen) { // N·∫øu chi ti·∫øt ƒëang ƒë√≥ng (v√† s·∫Ω m·ªü ra do click)
            // ƒê√≥ng t·∫•t c·∫£ c√°c chi ti·∫øt kh√°c
            document.querySelectorAll('details').forEach((d) => {
              if (d !== details && d.hasAttribute('open')) {
                d.removeAttribute('open');
              }
            });

            // M·ªü chi ti·∫øt hi·ªán t·∫°i
            details.setAttribute("open", "");
            highlightTOC(currentDetailIndex); // ƒê√°nh d·∫•u trong TOC
            details.scrollIntoView({ behavior: "smooth" }); // Cu·ªôn v√†o t·∫ßm nh√¨n

            // Di chuy·ªÉn c√°c ƒëi·ªÅu khi·ªÉn ph√°t v√†o thanh c·ªë ƒë·ªãnh v√† b·∫Øt ƒë·∫ßu ph√°t
            moveControlsToFixedBar(details, title, content, originalIndex);
            
          } else { // N·∫øu chi ti·∫øt ƒëang m·ªü (v√† s·∫Ω ƒë√≥ng l·∫°i do click)
            details.removeAttribute("open"); // ƒê√≥ng chi ti·∫øt
            // N·∫øu b√†i th∆° ƒëang ƒë√≥ng l√† b√†i ƒëang ph√°t, b·ªè ƒë√°nh d·∫•u trong TOC
            if (currentIndex === currentDetailIndex) {
                 highlightTOC(-1); // B·ªè ƒë√°nh d·∫•u t·∫•t c·∫£ trong TOC
                 currentIndex = -1; // ƒê·∫∑t l·∫°i ch·ªâ s·ªë b√†i ƒëang ph√°t
                 speechSynthesis.cancel(); // Stop speech when closing the active poem
                 isPlaying = false;
                 // Clear the fixed player bar
                 playerRow1Container.innerHTML = '';
                 playerRow2Container.innerHTML = '';
            }
          }
        };

        // T·∫°o ph·∫ßn th√¢n n·ªôi dung b√†i th∆°
        const body = document.createElement("div");
        body.className = "content-body";
        body.innerHTML = displayContent + (image ? `<img src="${image}" onerror="this.style.display='none';">` : "");

        // Append summary and body to details
        details.appendChild(summary);
        details.appendChild(body);
        container.appendChild(details);

        // T·∫°o li√™n k·∫øt trong m·ª•c l·ª•c
        const link = document.createElement("a");
        link.href = `#item-${originalIndex}`; // Use original index for stable ID
        link.innerHTML = displayTitle; // Use innerHTML for highlighted text
        link.onclick = e => {
          e.preventDefault();
          const targetDetails = document.getElementById(`item-${originalIndex}`);
          if (targetDetails) {
              // Ensure only this one is open
              document.querySelectorAll('details').forEach(d => d !== targetDetails && d.removeAttribute('open'));
              targetDetails.setAttribute("open", "");
              targetDetails.scrollIntoView({ behavior: "smooth", block: "start" }); // Cu·ªôn to top of details
              highlightTOC(originalIndex);
              moveControlsToFixedBar(targetDetails, title, content, originalIndex);
          }
        };
        toc.appendChild(link);
      });
    }

    /**
     * Handles playing the previous poem.
     */
    function playPrevious() {
        if (currentIndex > 0) {
            currentIndex--;
            const prevPoem = originalData[currentIndex];
            const targetDetails = document.getElementById(`item-${currentIndex}`);
            if (targetDetails) {
                document.querySelectorAll('details').forEach(d => d !== targetDetails && d.removeAttribute('open'));
                targetDetails.setAttribute("open", "");
                targetDetails.scrollIntoView({ behavior: "smooth", block: "start" });
                highlightTOC(currentIndex);
                moveControlsToFixedBar(targetDetails, prevPoem["Ti√™u ƒë·ªÅ"], prevPoem["N·ªôi dung"], currentIndex);
            } else {
                // If previous details element is not found, stop playback and clear controls
                speechSynthesis.cancel();
                isPlaying = false;
                playerRow1Container.innerHTML = '';
                playerRow2Container.innerHTML = '';
                currentIndex = -1; // Reset index
                highlightTOC(-1); // Clear TOC active state
            }
        } else {
            // If at the beginning of the list, stop playback and clear controls
            speechSynthesis.cancel();
            isPlaying = false;
            playerRow1Container.innerHTML = '';
            playerRow2Container.innerHTML = '';
            currentIndex = -1; // Reset index
            highlightTOC(-1); // Clear TOC active state
        }
    }

    /**
     * Handles playing the next poem.
     */
    function playNext() {
        if (currentIndex < originalData.length - 1) {
            currentIndex++;
            const nextPoem = originalData[currentIndex];
            const targetDetails = document.getElementById(`item-${currentIndex}`);
            if (targetDetails) {
                document.querySelectorAll('details').forEach(d => d !== targetDetails && d.removeAttribute('open'));
                targetDetails.setAttribute("open", "");
                targetDetails.scrollIntoView({ behavior: "smooth", block: "start" });
                highlightTOC(currentIndex);
                moveControlsToFixedBar(targetDetails, nextPoem["Ti√™u ƒë·ªÅ"], nextPoem["N·ªôi dung"], currentIndex);
            } else {
                // If next details element is not found, stop playback and clear controls
                speechSynthesis.cancel();
                isPlaying = false;
                playerRow1Container.innerHTML = '';
                playerRow2Container.innerHTML = '';
                currentIndex = -1; // Reset index
                highlightTOC(-1); // Clear TOC active state
            }
        } else {
            // If at the end of the list, stop playback and clear controls
            speechSynthesis.cancel();
            isPlaying = false;
            playerRow1Container.innerHTML = '';
            playerRow2Container.innerHTML = '';
            currentIndex = -1; // Reset index
            highlightTOC(-1); // Clear TOC active state
        }
    }

    /**
     * Creates and moves playback controls for a specific poem to the fixed player bar.
     * @param {HTMLElement} detailsElement - The <details> element of the poem.
     * @param {string} title - The title of the poem.
     * @param {string} content - The content of the poem.
     * @param {number} originalIndex - The original index of the poem.
     */
    function moveControlsToFixedBar(detailsElement, title, content, originalIndex) {
        // Clear previous controls in the fixed bar rows
        playerRow1Container.innerHTML = '';
        playerRow2Container.innerHTML = '';

        // --- Row 1 Controls (Existing) ---
        const btnToggle = document.createElement("button");
        btnToggle.innerHTML = "‚èØÔ∏è Ph√°t/D·ª´ng";
        btnToggle.onclick = () => {
          if (isPlaying && currentPlayingToggleButton === btnToggle) {
            speechSynthesis.cancel();
            isPlaying = false;
            btnToggle.innerHTML = "‚ñ∂Ô∏è Ph√°t";
          } else {
            currentIndex = originalIndex;
            speak(title + ". " + content, currentPlayingProgressBar, btnToggle);
          }
        };

        const btnAuto = document.createElement("button");
        btnAuto.innerHTML = "üîÅ L·∫∑p"; /* Changed to include the icon */
        btnAuto.classList.add("loop-toggle-button"); // Add new class for specific styling
        btnAuto.onclick = () => {
          autoPlay = !autoPlay; // Toggle global autoPlay
          btnAuto.classList.toggle("active-auto", autoPlay); // Update button visual
          btnAuto.setAttribute("aria-pressed", autoPlay); // Update aria-pressed for accessibility

          if (!autoPlay) { // If autoplay is turned off
            speechSynthesis.cancel(); // Stop current speech
            isPlaying = false;
            btnToggle.innerHTML = "‚ñ∂Ô∏è Ph√°t"; // Reset play button to 'Play'
            if (currentPlayingProgressBar) {
              clearInterval(progressInterval);
              currentPlayingProgressBar.style.width = "0%";
            }
            // Clear current playing context, as it's no longer auto-playing
            currentPlayingText = "";
            currentPlayingProgressBar = null;
            currentPlayingToggleButton = null;
          }
        };

        // Initialize btnAuto's visual state based on global autoPlay state
        btnAuto.classList.toggle("active-auto", autoPlay); 
        btnAuto.setAttribute("aria-pressed", autoPlay);


        const volLabel = document.createElement("label");
        volLabel.innerHTML = "üîâ";
        const volValueSpan = document.createElement("span"); // New span for volume value
        volValueSpan.textContent = `${(currentVolume * 10).toFixed(0)}`; // Initial value (0-10)
        const vol = document.createElement("input");
        vol.type = "range"; vol.min = 0; vol.max = 1; vol.step = 0.1; vol.value = currentVolume;
        vol.oninput = () => {
          currentVolume = parseFloat(vol.value);
          volValueSpan.textContent = `${(currentVolume * 10).toFixed(0)}`; // Update span (0-10)
          if (isPlaying && currentPlayingText && currentPlayingProgressBar && currentPlayingToggleButton) {
            speechSynthesis.cancel();
            speak(currentPlayingText, currentPlayingProgressBar, currentPlayingToggleButton);
          } else if (currentUtterance) {
            currentUtterance.volume = currentVolume;
          }
        };
        volLabel.append(volValueSpan, vol); // Append span and input to label

        const rateLabel = document.createElement("label");
        rateLabel.innerHTML = "‚è©";
        const rateValueSpan = document.createElement("span"); // New span for rate value
        rateValueSpan.textContent = `x${currentRate.toFixed(2)}`; // Initial value
        const rate = document.createElement("input");
        rate.type = "range"; rate.min = 0.5; rate.max = 2; rate.step = 0.25; rate.value = currentRate;
        rate.oninput = () => {
          currentRate = parseFloat(rate.value);
          rateValueSpan.textContent = `x${currentRate.toFixed(2)}`; // Update span
          if (isPlaying && currentPlayingText && currentPlayingProgressBar && currentPlayingToggleButton) {
            speechSynthesis.cancel();
            speak(currentPlayingText, currentPlayingProgressBar, currentPlayingToggleButton);
          } else if (currentUtterance) {
            currentUtterance.rate = currentRate;
          }
        };
        rateLabel.append(rateValueSpan, rate); // Append span and input to label

        // Create a div to hold the speech controls for proper CSS application
        const speechControlsDiv = document.createElement("div");
        speechControlsDiv.className = "speech-controls";
        speechControlsDiv.append(btnToggle, btnAuto, volLabel, rateLabel);
        playerRow1Container.appendChild(speechControlsDiv);


        // --- Row 2 Controls (New) ---
        const btnPrev = document.createElement("button");
        btnPrev.textContent = "‚èÆÔ∏è L√πi";
        btnPrev.onclick = playPrevious;

        const btnNext = document.createElement("button");
        btnNext.textContent = "Ti·∫øn ‚è≠Ô∏è";
        btnNext.onclick = playNext;

        const progressBar = document.createElement("div"); // Re-create progress bar here for row 2
        progressBar.className = "speech-progress-bar";

        const progressWrapper = document.createElement("div");
        progressWrapper.className = "speech-progress";
        progressWrapper.appendChild(progressBar);

        // Append to row 2 container
        playerRow2Container.append(btnPrev, progressWrapper, btnNext);


        // Start speaking the poem
        currentIndex = originalIndex;
        speak(title + ". " + content, progressBar, btnToggle);
    }


    /**
     * Ph√°t √¢m thanh t·ª´ vƒÉn b·∫£n.
     * @param {string} text - VƒÉn b·∫£n c·∫ßn ƒë·ªçc.
     * @param {HTMLElement} progressBar - Thanh ti·∫øn tr√¨nh ƒë·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i.
     * @param {HTMLElement} toggleButton - N√∫t ph√°t/d·ª´ng c·ªßa b√†i th∆° n√†y.
     */
    function speak(text, progressBar, toggleButton) {
      speechSynthesis.cancel(); // H·ªßy b·ªè b·∫•t k·ª≥ qu√° tr√¨nh ph√°t n√†o ƒëang di·ªÖn ra
      if (progressInterval) clearInterval(progressInterval); // X√≥a interval c≈© n·∫øu c√≥

      // L∆∞u tr·ªØ ng·ªØ c·∫£nh c·ªßa b√†i th∆° ƒëang ƒë∆∞·ª£c ph√°t
      currentPlayingText = text;
      currentPlayingProgressBar = progressBar;
      currentPlayingToggleButton = toggleButton;

      const utter = new SpeechSynthesisUtterance(text); // T·∫°o ƒë·ªëi t∆∞·ª£ng utterance
      utter.lang = "vi-VN"; // ƒê·∫∑t ng√¥n ng·ªØ l√† ti·∫øng Vi·ªát
      utter.volume = currentVolume; // ƒê·∫∑t √¢m l∆∞·ª£ng
      utter.rate = currentRate; // ƒê·∫∑t t·ªëc ƒë·ªô

      // T√¨m gi·ªçng ƒë·ªçc ti·∫øng Vi·ªát ∆∞u ti√™n, n·∫øu kh√¥ng c√≥ th√¨ d√πng gi·ªçng m·∫∑c ƒë·ªãnh ƒë·∫ßu ti√™n
      const voice = speechSynthesis.getVoices().find(v => v.lang.includes("vi")) || speechSynthesis.getVoices()[0];
      if (voice) utter.voice = voice;

      // X·ª≠ l√Ω khi b·∫Øt ƒë·∫ßu ph√°t
      utter.onstart = () => {
        isPlaying = true;
        // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t Play/Pause tr√™n UI
        if (currentPlayingToggleButton) {
            currentPlayingToggleButton.innerHTML = "‚è∏Ô∏è D·ª´ng";
        }
        if (currentPlayingProgressBar) { /* Use currentPlayingProgressBar */
          currentPlayingProgressBar.style.width = "0%"; // ƒê·∫∑t l·∫°i thanh ti·∫øn tr√¨nh v·ªÅ 0
          // ∆Ø·ªõc t√≠nh th·ªùi l∆∞·ª£ng d·ª±a tr√™n ƒë·ªô d√†i vƒÉn b·∫£n v√† t·ªëc ƒë·ªô
          let duration = text.length / currentRate / 15; // 15 l√† m·ªôt gi√° tr·ªã ∆∞·ªõc t√≠nh k√Ω t·ª±/gi√¢y
          let start = Date.now(); // Th·ªùi ƒëi·ªÉm b·∫Øt ƒë·∫ßu ph√°t

          // C·∫≠p nh·∫≠t thanh ti·∫øn tr√¨nh theo th·ªùi gian
          progressInterval = setInterval(() => {
            let elapsed = (Date.now() - start) / 1000; // Th·ªùi gian ƒë√£ tr√¥i qua (gi√¢y)
            let percent = Math.min(100, (elapsed / duration) * 100); // T√≠nh ph·∫ßn trƒÉm
            currentPlayingProgressBar.style.width = percent + "%"; /* Use currentPlayingProgressBar */
          }, 100); // C·∫≠p nh·∫≠t m·ªói 100ms
        }
      };

      // X·ª≠ l√Ω khi k·∫øt th√∫c ph√°t
      utter.onend = () => {
        isPlaying = false;
        // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t Play/Pause tr√™n UI
        if (currentPlayingToggleButton) {
            currentPlayingToggleButton.innerHTML = "‚ñ∂Ô∏è Ph√°t";
        }
        if (currentPlayingProgressBar) currentPlayingProgressBar.style.width = "100%"; /* Use currentPlayingProgressBar */
        if (progressInterval) clearInterval(progressInterval); // X√≥a interval

        // X√≥a ng·ªØ c·∫£nh ƒëang ph√°t
        currentPlayingText = "";
        currentPlayingProgressBar = null;
        currentPlayingToggleButton = null;

        if (autoPlay) { // If autoPlay is true, play next randomly
          let nextIndex;
          // Ensure we don't pick the same poem if there's more than one
          if (originalData.length > 1) {
            do {
              nextIndex = Math.floor(Math.random() * originalData.length);
            } while (nextIndex === currentIndex); // Keep picking until it's different from current
          } else {
            // Only one poem, so just play it again if loop is on.
            nextIndex = currentIndex;
          }


          const nextDetails = document.querySelector(`#item-${nextIndex}`);
          if (nextDetails) {
            // Ensure only this one is open
            document.querySelectorAll("details").forEach(d => d !== nextDetails && d.removeAttribute("open"));
            nextDetails.setAttribute("open", "");
            nextDetails.scrollIntoView({ behavior: "smooth", block: "start" });
            const nextRow = originalData[nextIndex];
            currentIndex = nextIndex; // Update currentIndex for random
            // Re-call moveControlsToFixedBar to re-initialize controls for the new poem
            moveControlsToFixedBar(nextDetails, nextRow["Ti√™u ƒë·ªÅ"], nextRow["N·ªôi dung"], currentIndex);
          } else {
            // Fallback if somehow nextDetails not found (e.g., filtered data issues)
            playerRow1Container.innerHTML = '';
            playerRow2Container.innerHTML = '';
          }
        } else {
            // Autoplay is off, stop and clear the fixed player bar
            playerRow1Container.innerHTML = '';
            playerRow2Container.innerHTML = '';
        }
      };

      currentUtterance = utter; // L∆∞u tr·ªØ ƒë·ªëi t∆∞·ª£ng utterance hi·ªán t·∫°i
      speechSynthesis.speak(utter); // B·∫Øt ƒë·∫ßu ph√°t √¢m thanh
    }

    /**
     * ƒê√°nh d·∫•u li√™n k·∫øt trong m·ª•c l·ª•c l√† "active".
     * @param {number} index - Ch·ªâ s·ªë c·ªßa b√†i th∆° c·∫ßn ƒë√°nh d·∫•u.
     */
    function highlightTOC(index) {
      document.querySelectorAll(".toc a").forEach((a, i) => {
        a.classList.toggle("active", i === index); // Th√™m/b·ªè class 'active'
      });
    }

    /**
     * Hi·ªÉn th·ªã danh s√°ch g·ª£i √Ω t√¨m ki·∫øm.
     * @param {Array} fuseResults - M·∫£ng c√°c ƒë·ªëi t∆∞·ª£ng FuseResult ƒë·ªÉ hi·ªÉn th·ªã l√†m g·ª£i √Ω.
     */
    function displaySuggestions(fuseResults) {
        searchSuggestions.innerHTML = ''; // Clear previous suggestions

        if (fuseResults.length === 0 || searchInput.value.trim() === "") {
            searchSuggestions.style.display = 'none';
            searchWrapper.classList.remove('suggestions-open'); // Remove class when no suggestions
            return;
        }

        // Limit to top 5 suggestions for cleaner display
        fuseResults.slice(0, 5).forEach((fuseResult) => {
            const li = document.createElement('li');
            li.textContent = fuseResult.item["Ti√™u ƒë·ªÅ"] || `B√†i ${originalData.indexOf(fuseResult.item) + 1}`;
            li.addEventListener('click', () => {
                searchInput.value = li.textContent; // Fill search input with selected title
                searchSuggestions.style.display = 'none'; // Hide suggestions
                searchWrapper.classList.remove('suggestions-open'); // Remove class
                searchResultCountElement.textContent = ""; // Hide result info

                // Render only the selected item
                renderContent([fuseResult.item]); // Pass the original item for rendering

                // After rendering the exact match, ensure it's open and plays
                const matchedIndex = originalData.indexOf(fuseResult.item);
                if (matchedIndex !== -1) {
                    const targetDetails = document.getElementById(`item-${matchedIndex}`);
                    if (targetDetails) {
                        // Ensure only this one is open
                        document.querySelectorAll('details').forEach(d => d !== targetDetails && d.removeAttribute('open'));
                        targetDetails.setAttribute("open", "");
                        targetDetails.scrollIntoView({ behavior: "smooth", block: "start" });
                        highlightTOC(matchedIndex);
                        const title = fuseResult.item["Ti√™u ƒë·ªÅ"];
                        const content = fuseResult.item["N·ªôi dung"];
                        moveControlsToFixedBar(targetDetails, title, content, matchedIndex);
                    }
                }
            });
            searchSuggestions.appendChild(li);
        });
        searchSuggestions.style.display = 'block'; // Show suggestions
        searchWrapper.classList.add('suggestions-open'); // Add class when suggestions are shown
    }


    /**
     * X·ª≠ l√Ω s·ª± ki·ªán nh·∫≠p li·ªáu v√†o √¥ t√¨m ki·∫øm.
     */
    searchInput.addEventListener("input", function () {
      const keyword = this.value.trim();

      if (!keyword) {
        searchResultCountElement.textContent = "";
        renderContent(originalData); // Render all if no keyword
        displaySuggestions([]); // Clear and hide suggestions
        // Also clear the fixed player bar if no search results and no current poem
        if (currentIndex === -1 || !isPlaying) {
            playerRow1Container.innerHTML = '';
            playerRow2Container.innerHTML = '';
        }
        return;
      }

      // Use Fuse.js for searching
      if (fuse) {
          const results = fuse.search(keyword);
          const matchedItems = results.map(r => r.item);

          // Update result count message
          searchResultCountElement.textContent = `ƒê√£ t√¨m th·∫•y ${matchedItems.length} k·∫øt qu·∫£ cho t·ª´ kh√≥a "${keyword}"`;
          searchResultCountElement.style.display = 'block'; // Ensure it's visible

          displaySuggestions(results); // Pass full Fuse results to suggestions for consistency

          // Render content based on filtered results for the main view
          renderContent(matchedItems); // Pass the original items for rendering

          // Scroll to the first result if any
          if (matchedItems.length > 0) {
              const firstResultOriginalIndex = originalData.indexOf(matchedItems[0]);
              if (firstResultOriginalIndex !== -1) {
                  const firstDetails = document.getElementById(`item-${firstResultOriginalIndex}`);
                  if (firstDetails) {
                      // Open and scroll to the first result
                      document.querySelectorAll('details').forEach(d => d !== firstDetails && d.removeAttribute('open'));
                      firstDetails.setAttribute("open", "");
                      firstDetails.scrollIntoView({ behavior: "smooth", block: "start" });
                      highlightTOC(firstResultOriginalIndex);
                      // Auto-play the first result (as per previous request)
                      const title = originalData[firstResultOriginalIndex]["Ti√™u ƒë·ªÅ"];
                      const content = originalData[firstResultOriginalIndex]["N·ªôi dung"];
                      moveControlsToFixedBar(firstDetails, title, content, firstResultOriginalIndex);
                  }
              }
          } else {
            // If no results, clear the accordion and TOC active state
            document.getElementById("accordion").innerHTML = '<p style="text-align: center; margin-top: 20px; color: #6c757d;">Kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ n√†o ph√π h·ª£p.</p>';
            highlightTOC(-1); // Clear TOC active state
            speechSynthesis.cancel(); // Stop any ongoing speech
            isPlaying = false;
            // Clear the fixed player bar if no results
            playerRow1Container.innerHTML = '';
            playerRow2Container.innerHTML = '';
          }
      } else {
          console.warn("Fuse.js not initialized. Search functionality is disabled.");
          searchResultCountElement.textContent = "Ch·ª©c nƒÉng t√¨m ki·∫øm kh√¥ng kh·∫£ d·ª•ng.";
          searchResultCountElement.style.display = 'block';
          // Render original content if search is disabled
          renderContent(originalData);
          playerRow1Container.innerHTML = '';
          playerRow2Container.innerHTML = '';
      }
    });

    // ·∫®n g·ª£i √Ω khi √¥ t√¨m ki·∫øm m·∫•t ti√™u ƒëi·ªÉm
    searchInput.addEventListener('blur', () => {
        // S·ª≠ d·ª•ng setTimeout ƒë·ªÉ cho ph√©p s·ª± ki·ªán click tr√™n g·ª£i √Ω k·ªãp th·ªùi k√≠ch ho·∫°t
        setTimeout(() => {
            searchSuggestions.style.display = 'none';
            searchWrapper.classList.remove('suggestions-open'); // Remove class on blur
        }, 150);
    });

    // Hi·ªÉn th·ªã l·∫°i g·ª£i √Ω khi √¥ t√¨m ki·∫øm c√≥ ti√™u ƒëi·ªÉm v√† c√≥ n·ªôi dung
    searchInput.addEventListener('focus', () => {
        if (searchInput.value.trim() !== "") {
            // Re-trigger input event to re-filter and show suggestions
            searchInput.dispatchEvent(new Event('input'));
        }
    });

    // S·ª± ki·ªán khi danh s√°ch gi·ªçng ƒë·ªçc thay ƒë·ªïi (ƒë·∫£m b·∫£o gi·ªçng ƒë·ªçc ƒë∆∞·ª£c t·∫£i)
    window.speechSynthesis.onvoiceschanged = () => {
      // C√≥ th·ªÉ th√™m logic ƒë·ªÉ ch·ªçn gi·ªçng m·∫∑c ƒë·ªãnh ·ªü ƒë√¢y n·∫øu c·∫ßn, nh∆∞ng hi·ªán t·∫°i ƒë√£ x·ª≠ l√Ω trong h√†m speak
    };

    // T·∫£i d·ªØ li·ªáu khi trang web ƒë∆∞·ª£c t·∫£i (ch·∫°y ngay sau khi DOM ƒë∆∞·ª£c t·∫£i)
    loadData();
  </script>
</body>
</html>
